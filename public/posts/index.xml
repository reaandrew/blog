<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Andy Rea&#39;s Blog</title>
    <link>https://reaandrew.github.io/posts/</link>
    <description>Recent content in Posts on Andy Rea&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-gb</language>
    <managingEditor>email@andrewrea.co.uk (Andy Rea)</managingEditor>
    <webMaster>email@andrewrea.co.uk (Andy Rea)</webMaster>
    <lastBuildDate>Mon, 19 Aug 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://reaandrew.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Enumerating Github Repositories in Bash</title>
      <link>https://reaandrew.github.io/posts/enumerating-github-repositories-in-bash/</link>
      <pubDate>Mon, 19 Aug 2019 00:00:00 +0000</pubDate>
      <author>email@andrewrea.co.uk (Andy Rea)</author>
      <guid>https://reaandrew.github.io/posts/enumerating-github-repositories-in-bash/</guid>
      <description>I needed to get a list of all the repositories for a specific Github Organisation. Github limits the page size which you have use which ruled out a single call with a large value. I was also writing this routine in bash and less is more as they say.
My approach was very simplistic in that it simply tried an incrementing value for next page and if the response was empty then the end of the list had been reached.</description>
    </item>
    
    <item>
      <title>Creating a Simple Stress Test Tool in Go Part 2</title>
      <link>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-2/</link>
      <pubDate>Mon, 10 Jun 2019 20:22:20 +0000</pubDate>
      <author>email@andrewrea.co.uk (Andy Rea)</author>
      <guid>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-2/</guid>
      <description>Must be a CLI I chose the Cobra https://github.com/spf13/cobra package for the CLI since it is used by a lot of popular applications and it made things a lot simpler than working with the raw command line arguments, including testing etc&amp;hellip; In my opinion this is one of those decisions better made early so more focus can be given to the actual requirements. To get started I literally installed the generator and package with two separate go gets as per the documentation which created a default root command which I could build on.</description>
    </item>
    
    <item>
      <title>Creating a Simple Stress Test Tool in Go Part 1</title>
      <link>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-1/</link>
      <pubDate>Sun, 09 Jun 2019 14:43:46 +0000</pubDate>
      <author>email@andrewrea.co.uk (Andy Rea)</author>
      <guid>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go-part-1/</guid>
      <description>Must be continually built and published to github releases supporting Windows, Linux and Mac The first part is to create a new repository and setup the continuous integration environment which I will use github and circleci for respectively. I will name the repository and the project surge. https://github.com/reaandrew/surge.git
To begin with I will create a simple hello world application to flush the pipeline with circleci.
package main import &amp;#34;fmt&amp;#34; func main() { fmt.</description>
    </item>
    
    <item>
      <title>Creating a Simple Stress Test Tool in Go - Requirements</title>
      <link>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go/</link>
      <pubDate>Sun, 09 Jun 2019 13:43:46 +0000</pubDate>
      <author>email@andrewrea.co.uk (Andy Rea)</author>
      <guid>https://reaandrew.github.io/posts/creating-a-simple-stress-test-tool-in-go/</guid>
      <description>Introduction One of the tools that has really stuck in my mind over the years is the siege stress test tool https://github.com/JoeDog/siege. It was really simple to use, give it a list of urls, add some command line arguments including concurrency, time etc&amp;hellip; and it would begin testing those urls with really clear output. At the end of the test run it would print out statistics for the entire test like requests per second, average response time etc&amp;hellip; One thing it also did was make a log of these statistics in tabular form in a file in the home directory which was really useful to compare performance against historical runs.</description>
    </item>
    
    <item>
      <title>Getting back into blogging with Hugo!</title>
      <link>https://reaandrew.github.io/posts/getting-back-into-blogging-with-hugo/</link>
      <pubDate>Sat, 08 Jun 2019 00:00:00 +0000</pubDate>
      <author>email@andrewrea.co.uk (Andy Rea)</author>
      <guid>https://reaandrew.github.io/posts/getting-back-into-blogging-with-hugo/</guid>
      <description>This is a first blog post whilst I get this site back up and running using Hugo.
The deployment option which I am using is the one where you use one github repository to store all the source and raw material and another github repository for the generated artefacts which are then published on github pages. There other ways of doing this (e.g. using a branch), which I tried, but I settled with the two repos approach.</description>
    </item>
    
  </channel>
</rss>